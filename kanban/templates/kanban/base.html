{% load static %}
<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <meta http-equiv="x-ua-compatible" content="ie=edge">
 <meta name="description" content="">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>AE Stocks</title>
 <script src="//bensmithett.github.io/dragster/lib/dragster.js"></script>
 <link rel="stylesheet" href="{% static 'css/kanban.css' %}">
</head>

<body>
 {% block content %}{% endblock %}

 <h1>아프리카 코끼리</h1>

 {% for board in boards %} 
 <h2>{{ board.name }}</h2>

 <!-- Top30 메인 리스트 / 별도 db 사용 / 수정 불가 -->
  <div class="board" >
    <div class="column">
        <h3>Top 30</h3>
        {% for card in tops %}
        <a class="card" draggable="true" data-card-title="{{ card.title }}">{{ card.title }} {{ card.rate }} {{ card.market }} </a>
        {% endfor %}
    </div>
 
    <!-- 종목 정리용 리스트 / 생성, 삭제 가능 / 리스트는 메인리스트에서 가져옴 -->
    {% for column in board.columns.all %}
    <div class="column" data-column-id="{{ column.id }}" draggable="true">
      <div class="c-title" style="float:left">
        <!-- 컬럼 타이틀 -->
        <form action="/new-col-name/" method="POST">
          {% csrf_token %}
          <input id="c-title-hidden" type="hidden" name="column_id" value="{{ column.id }}" />
          <input id ="c-title-text" type="text" name="title" class="new-col-name no-display" data-column-id="{{ column.id }}" />
        </form>
        <button id="c-title-button" class="column-title" data-column-id="{{ column.id }}">{{ column.title }}</button>
      </div>

      <!-- 컬럼 삭제 버튼  -->
      <div class="c-delete" sytle="float:right">
        <form action="/delete-column/" method="POST" >
          {% csrf_token %}
          <input type="hidden" name="column_id" value="{{ column.id }}" />
          <button class="delete-button" type='submit'>delete</button>
        </form>
      </div>
        
        {% for card in column.cards.all %}
        <a class="card" draggable="true" ondragstart="startDrag(event)" ondragend="endDrag(event)" data-card-title="{{ card.title }}" href="/cards/{{ card.id }}/{{ card.slug }}/">{{ card.title }}</a>
        {% endfor %}
      

        <form action="/new-card/" method="POST">
          {% csrf_token %}
          <input type="hidden" name="column_id" value="{{ column.id }}" />
          <input id ="new-card-text" type="text" name="title" class="new-card no-display" data-column-id="{{ column.id }}" />
        </form>
        <button id="add-card-button" class="show-new-card" data-column-id="{{ column.id }}">+ Add a card</button>
      </div>
      {% endfor %}
    <!-- 새 컬럼 추가 버튼 -->
    <form action="/new-list/" method="POST">
      {% csrf_token %}
      <input type="hidden" name="board_id" value="{{ board.id }}" />
      <input id="add-list-text" type="text" name="title" class="new-list no-display" data-board-id="{{ board.id }}" />
    </form>
    <button id="add-list-button" class="show-new-list" data-board-id="{{ board.id }}">+ Add a new list</button>
  </div>
 
  {% empty %}
  <p><em>No boards created yet!</em></p>
  {% endfor %}

<script>
   
   function parse_cookies() {
      var cookies = {};
      if (document.cookie && document.cookie !== '') {
         document.cookie.split(';').forEach(function (c) {
         var m = c.trim().match(/(\w+)=(.*)/);
         if(m !== undefined) {
         cookies[m[1]] = decodeURIComponent(m[2]);
         }
         });
      }
      return cookies;
   }
   const cookies = parse_cookies();

   // 입력창 취소 관련 focus된 아이템 저장
   var previousActiveElement=null;

   document.onmousedown = function(e) {
      previousActiveElement = document.activeElement;
   }
  
   // 외부 영역 클릭해서 취소하기
   document.onclick = function(e) {
      var targetElement = e.target;
      var currentActiveElement = document.activeElement;

      if (currentActiveElement.dataset.columnId === undefined && previousActiveElement.dataset.columnId === undefined && currentActiveElement.className !== 'new-list' && previousActiveElement.className !== 'new-list' && previousActiveElement.className !== 'new-card-name') {return;}
      else if (previousActiveElement.className === 'new-card') {
         if (currentActiveElement.dataset.columnId === undefined || previousActiveElement.className !== currentActiveElement.className || currentActiveElement.dataset.columnId !== previousActiveElement.dataset.columnId) {
            previousActiveElement.classList.add('no-display')
         }
      }
      else if (previousActiveElement.className === "new-col-name") {
         if (currentActiveElement.dataset.columnId === undefined || previousActiveElement.className !== currentActiveElement.className || currentActiveElement.dataset.columnId !== previousActiveElement.dataset.columnId) {
            previousActiveElement.classList.add('no-display');
            // document.getElementsByClassName("column-title").className = "column-title"
            const columnTitle = document.querySelector('.column-title[data-column-id="' + previousActiveElement.dataset.columnId + '"]');
            columnTitle.classList.remove('no-display');
         }
      }
      else if (previousActiveElement.className === "new-list") {
         if (currentActiveElement.dataset.columnId === undefined || previousActiveElement.className !== currentActiveElement.className || currentActiveElement.dataset.columnId !== previousActiveElement.dataset.columnId) {
            previousActiveElement.classList.add('no-display');
            document.getElementById('add-list-button').classList.remove('no-display');
         }
      }
      else if (previousActiveElement.className === "new-card-name") {
         if (currentActiveElement.dataset.cardTitle === undefined || previousActiveElement.className !== currentActiveElement.className || currentActiveElement.dataset.cardTitle !== previousActiveElement.dataset.cardTitle) {
            previousActiveElement.classList.add('no-display');
            document.getElementById('card-title-button').classList.remove('no-display');
         }
      }   
   }

   // ESC키로 입력 취소
   document.onkeydown = function(e) {
      var activeElement = document.activeElement;

      if (e.keyCode !== 27) {return;}
      else if (activeElement.className === 'new-col-name') {
         activeElement.classList.add('no-display');
         const columnTitle = document.querySelector('.column-title[data-column-id="' + activeElement.dataset.columnId + '"]');
         columnTitle.classList.remove('no-display');
      }
      else if (activeElement.className === 'new-card') {
         activeElement.classList.add('no-display');
      }
      else if (activeElement.className === 'new-list') {
         activeElement.classList.add('no-display');
         document.getElementById('add-list-button').classList.remove('no-display');
      }
      else if (activeElement.className === 'new-card-name') {
         activeElement.classList.add('no-display');
         document.getElementById('card-title-button').classList.remove('no-display');
      }
     
   }

   // 드래그 시작 시, 원래 카드 숨기기
   function startDrag(e) {
      var element = e.target;
      setTimeout(function(){
      element.classList.add('no-display');
      });
   }

   function endDrag(e) {
      var element = e.srcElement;
      element.classList.remove('no-display');
   }


   // 새 카드 만드는 버튼 액션 정의
   for (button of document.getElementsByClassName('show-new-card')) {
      button.addEventListener('click', e => {
         const newCard = document.querySelector('.new-card[data-column-id="' + e.currentTarget.dataset.columnId + '"]');
         newCard.classList.remove('no-display');
         newCard.focus();
      });
   }

   // 새 리스트 만드는 버튼 액션 정의 
   for (button of document.getElementsByClassName('show-new-list')) {
      button.addEventListener('click', e => {
         const newList = document.querySelector('.new-list[data-board-id="' + e.currentTarget.dataset.boardId + '"]');
         newList.classList.remove('no-display');
         e.currentTarget.classList.add('no-display');
         newList.focus();
      });
   }

   // 리스트 이름 클릭에 관련된 액션
   for (button of document.getElementsByClassName('column-title')) {
      button.addEventListener('mouseup', e => {
         const newColName = document.querySelector('.new-col-name[data-column-id="' + e.currentTarget.dataset.columnId + '"]');
         newColName.classList.remove('no-display');
         e.currentTarget.classList.add('no-display');
         newColName.focus();
      });
   }

   // 팝업창에서 카드 이름 변경하기 액션
   for (button of document.getElementsByClassName('card-title')) {
        button.addEventListener('click', e=> {
            const newCardTitle= document.querySelector('.new-card-name[data-card-title="' + e.currentTarget.dataset.cardTitle + '"]');
            newCardTitle.classList.remove('no-display');
            e.currentTarget.classList.add('no-display');
            newCardTitle.focus();
        });
    }

   for (card of document.getElementsByClassName('card')) {
      card.addEventListener('dragstart', e => {
      e.dataTransfer.setData('Text', e.currentTarget.dataset.cardTitle);
      });
   }

   for (element of document.getElementsByClassName('column')) {
      new Dragster(element);
      element.addEventListener('dragover', e => {
         if (e.preventDefault) e.preventDefault();
      });

    element.addEventListener('dragster:enter', e => {
      e.currentTarget.classList.add('dropme');
      element.clssList.add('dropme');
      });

    element.addEventListener('dragster:leave', e => {
      e.currentTarget.classList.remove('dropme')
      });
      
    element.addEventListener('drop', e => {
      e.currentTarget.classList.remove('dropme');
      const postData = JSON.stringify({
        'column_id': e.currentTarget.dataset.columnId,
        'card_title': e.dataTransfer.getData('Text'),
        });

    fetch('/drop/', {
     credentials: 'same-origin',
     method: 'post',
     headers: {
      'X-CSRFToken': cookies['csrftoken'],
     },
     body: postData,
    }).then(response => {
     if (response.ok) {
      window.location = '/';
     } else {
      alert('Error! ' + response.statusText);
     }
    });

   });
  }

  // 카드 옮겨서 sorting 하는 코드. 수정 중

  (function( name, factory ) {
   
   if( typeof window === "object" ) {
      
      // add to window 
      window[ name ] = factory();
      
      // add jquery plugin, if available  
      if( typeof jQuery === "object" ) {
         jQuery.fn[ name ] = function( options ) {
            return this.each( function() {
               new window[ name ]( this, options );
            });
         };
      }
   }
    
})( "Sortable", function() {
   
   var _w = window,
       _b = document.body,
       _d = document.documentElement;
   
   // get position of mouse/touch in relation to viewport 
   var getPoint = function( e )
   {
      var scrollX = Math.max( 0, _w.pageXOffset || _d.scrollLeft || _b.scrollLeft || 0 ) - ( _d.clientLeft || 0 ), 
          scrollY = Math.max( 0, _w.pageYOffset || _d.scrollTop || _b.scrollTop || 0 ) - ( _d.clientTop || 0 ), 
          pointX  = e ? ( Math.max( 0, e.pageX || e.clientX || 0 ) - scrollX ) : 0,
          pointY  = e ? ( Math.max( 0, e.pageY || e.clientY || 0 ) - scrollY ) : 0; 
      
      return { x: pointX, y: pointY }; 
   }; 
   
   // class constructor
   var Factory = function( container, options )
   {
      if( container && container instanceof Element )
      {
         this._container = container; 
         this._options   = options || {}; /* nothing atm */
         this._clickItem = null;
         this._dragItem  = null;
         this._hovItem   = null;
         this._sortLists = [];
         this._click     = {};
         this._dragging  = false;
         
         this._container.setAttribute( "data-is-sortable", 1 );
         this._container.style["position"] = "static";
         
         window.addEventListener( "mousedown", this._onPress.bind( this ), true );
         window.addEventListener( "touchstart", this._onPress.bind( this ), true );
         window.addEventListener( "mouseup", this._onRelease.bind( this ), true ); 
         window.addEventListener( "touchend", this._onRelease.bind( this ), true ); 
         window.addEventListener( "mousemove", this._onMove.bind( this ), true );
         window.addEventListener( "touchmove", this._onMove.bind( this ), true );
      }
   };
   
   // class prototype
   Factory.prototype = {
      constructor: Factory,
      
      // serialize order into array list 
      toArray: function( attr )
      {
         attr = attr || "id";
         
         var data = [], 
             item = null, 
             uniq = ""; 
         
         for( var i = 0; i < this._container.children.length; ++i )
         {
            item = this._container.children[ i ], 
            uniq = item.getAttribute( attr ) || "";
            uniq = uniq.replace( /[^0-9]+/gi, "" );
            data.push( uniq );
         }
         return data;
      }, 
      
      // serialize order array into a string 
      toString: function( attr, delimiter )
      {
         delimiter = delimiter || ":"; 
         return this.toArray( attr ).join( delimiter );
      }, 
      
      // checks if mouse x/y is on top of an item 
      _isOnTop: function( item, x, y )
      {
         var box = item.getBoundingClientRect(),
             isx = ( x > box.left && x < ( box.left + box.width ) ), 
             isy = ( y > box.top && y < ( box.top + box.height ) ); 
         return ( isx && isy );
      },
      
      // manipulate the className of an item (for browsers that lack classList support)
      _itemClass: function( item, task, cls )
      {
         var list  = item.className.split( /\s+/ ), 
             index = list.indexOf( cls );
         
         if( task === "add" && index == -1 )
         { 
            list.push( cls ); 
            item.className = list.join( " " ); 
         }
         else if( task === "remove" && index != -1 )
         {
            list.splice( index, 1 ); 
            item.className = list.join( " " ); 
         }
      }, 
      
      // swap position of two item in sortable list container 
      _swapItems: function( item1, item2 )
      {
         var parent1 = item1.parentNode, 
             parent2 = item2.parentNode;
         
         if( parent1 !== parent2 ) 
         {
            // move to new list 
            parent2.insertBefore( item1, item2 );
         }
         else { 
            // sort is same list 
            var temp = document.createElement( "div" ); 
            parent1.insertBefore( temp, item1 );
            parent2.insertBefore( item1, item2 );
            parent1.insertBefore( item2, temp );
            parent1.removeChild( temp );
         }
      },
      
      // update item position 
      _moveItem: function( item, x, y )
      {
         item.style["-webkit-transform"] = "translateX( "+ x +"px ) translateY( "+ y +"px )";
         item.style["-moz-transform"] = "translateX( "+ x +"px ) translateY( "+ y +"px )";
         item.style["-ms-transform"] = "translateX( "+ x +"px ) translateY( "+ y +"px )";
         item.style["transform"] = "translateX( "+ x +"px ) translateY( "+ y +"px )";
      },
      
      // make a temp fake item for dragging and add to container 
      _makeDragItem: function( item )
      {
         this._trashDragItem(); 
         this._sortLists = document.querySelectorAll( "[data-is-sortable]" );
         
         this._clickItem = item; 
         this._itemClass( this._clickItem, "add", "active" ); 

         this._dragItem = document.createElement( item.tagName );
         this._dragItem.className = "dragging"; 
         this._dragItem.innerHTML = item.innerHTML; 
         this._dragItem.style["position"] = "absolute";
         this._dragItem.style["z-index"] = "999";
         this._dragItem.style["left"] = ( item.offsetLeft || 0 ) + "px";
         this._dragItem.style["top"] = ( item.offsetTop || 0 ) + "px";
         this._dragItem.style["width"] = ( item.offsetWidth || 0 ) + "px";
         
         this._container.appendChild( this._dragItem ); 
      }, 
      
      // remove drag item that was added to container 
      _trashDragItem: function()
      {
         if( this._dragItem && this._clickItem )
         {
            this._itemClass( this._clickItem, "remove", "active" ); 
            this._clickItem = null; 
            
            this._container.removeChild( this._dragItem ); 
            this._dragItem = null; 
         }
      }, 
      
      // on item press/drag 
      _onPress: function( e )
      {
         if( e && e.target && e.target.parentNode === this._container )
         {
            e.preventDefault();
            
            this._dragging = true;
            this._click = getPoint( e ); 
            this._makeDragItem( e.target ); 
            this._onMove( e );
         }
      },
      
      // on item release/drop 
      _onRelease: function( e )
      {
         this._dragging = false;
         this._trashDragItem(); 
      },
      
      // on item drag/move
      _onMove: function( e )
      {
         if( this._dragItem && this._dragging ) 
         {
            e.preventDefault();
            
            var point     = getPoint( e ); 
            var container = this._container;

            // drag fake item 
            this._moveItem( this._dragItem, ( point.x - this._click.x ), ( point.y - this._click.y ) ); 
            
            // keep an eye for other sortable lists and switch over to it on hover 
            for( var a = 0; a < this._sortLists.length; ++a )
            {
               var subContainer = this._sortLists[ a ]; 
               
               if( this._isOnTop( subContainer, point.x, point.y ) ) 
               {
                  container = subContainer;
               }
            }
            
            // container is empty, move clicked item over to it on hover 
            if( this._isOnTop( container, point.x, point.y ) && container.children.length === 0 ) 
            {
               container.appendChild( this._clickItem ); 
               return; 
            }
            
            // check if current drag item is over another item and swap places 
            for( var b = 0; b < container.children.length; ++b )
            {
               var subItem = container.children[ b ]; 
               
               if( subItem === this._clickItem || subItem === this._dragItem )
               {
                  continue; 
               }
               if( this._isOnTop( subItem, point.x, point.y ) ) 
               {
                  this._hovItem = subItem; 
                  this._swapItems( this._clickItem, subItem ); 
               }
            }
         }
      },
      
   };

   // export
   return Factory;
});


// helper init function 
function initSortable( list )
{
   var listObj  = document.getElementById( list ),
      //  sbtnObj  = document.getElementById( sbtn ),
       sortable = new Sortable( listObj ); 
   
 
}

// init lists 
initSortable( "list-1");
// initSortable( "list-2", "sbtn-2" );
 </script>

</body>
</html>
